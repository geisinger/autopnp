/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id$
 */

/**
 * \file
 *         Main file of node 'cleaningGuiNode'.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (XMT)
 *         (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "autopnp/adv/cleaningGui/include/cleaningGuiComponentWrapper.h"
#include "autopnp/adv/cleaningGui/include/displayImageFunction.h"
#include "autopnp/adv/cleaningGui/include/displayImageFunctionWrapper.h"
#include "autopnp/topic/dictionary.h"
#include "autopnp/wp/marshaler/include/demarshaler.h"
#include "autopnp/wp/marshaler/include/demarshalerFunctionWrapper.h"
#include "autopnp/wp/marshaler/include/marshaler.h"
#include "autopnp/wp/marshaler/include/marshalerFunctionWrapper.h"
#include "xme/core/broker/include/broker.h"
#include "xme/core/broker/include/brokerPnpManagerInterface.h"
#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/executionManager/include/executionManagerScheduleManagementInterface.h"
#include "xme/core/log.h"
#include "xme/core/topic.h"
#include "xme/hal/include/context.h"
#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/sharedPtr.h"
#include "xme/hal/include/sync.h"
#include "xme/hal/include/time.h"
#include "xme/hal/include/tls.h"
#include "xme/wp/udp/include/udpReceive.h"
#include "xme/wp/udp/include/udpReceiveWayPointFunctionWrapper.h"
#include "xme/wp/udp/include/udpSend.h"
#include "xme/wp/udp/include/udpSendWayPointFunctionWrapper.h"

/******************************************************************************/
/***   Static variables                                                     ***/
/******************************************************************************/
/**
 * \brief  Array of all ports on this node.
 */
static xme_core_dataManager_dataPacketId_t ports[1];


/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Initialize CHROMOSOME hal and core components.
 *
 * \retval XME_STATUS_SUCCESS when initialization succeeded without problems.
 * \retval XME_STATUS_OUT_OF_RESOURCES when an error occured during initialization
 *         of one of the core components.
 */
xme_status_t 
xmeInit(void);

/**
 * \brief  Initialize component 'cleaningGui'.
 *
 * \details Creates ports, populates given function descriptor and registers component
 *          functions at the broker.
 *
 * \param  descriptor Function descriptor for this component.
 *
 * \retval XME_STATUS_SUCCESS When initialization succeded without errors.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 * \retval XME_STATUS_INTERNAL_ERROR When an error occured during initialization.
 */
xme_status_t
cleaningGuiInit
(
	xme_core_exec_functionDescriptor_t** descriptor
);

/**
 * \brief  Frees resources allocated by component 'cleaningGui'.
 *
 * \param  descriptor Function descriptor of the component that should be finalized.
 */
void
cleaningGuiFini
(
	xme_core_exec_functionDescriptor_t* descriptor
);


/**
 * \brief  Initialize marshaler waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
marshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the marshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the marshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  inputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
marshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
marshalerWaypointFini(void);

/**
 * \brief  Initialize demarshaler waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
demarshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the demarshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the demarshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  outputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
demarshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
demarshalerWaypointFini(void);

/**
 * \brief  Initialize udp send waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
udpSendWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp send waypoint.
 *
 * \details Creates and adds configuration structure for udp send waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpSend_addConfig.
 * \param  destIP See hostname parameter of xme_wp_udp_udpSend_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpSend_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpSend_addConfig.
 * \param  sendBuffer See buffer parameter of xme_wp_udp_udpSend_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpSendWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
udpSendWaypointFini(void);

/**
 * \brief  Initialize udp receive waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
udpReceiveWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp receive waypoint.
 *
 * \details Creates and adds configuration structure for udp receive waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  recvBuffer See buffer parameter of xme_wp_udp_udpReceive_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpReceiveWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
udpReceiveWaypointFini(void);

/**
 * \brief  Add packet transfer entries for all ports to the broker.
 */
void
addDataPacketTransferEntries(void);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xmeInit(void)
{
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sync_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sched_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_init(18), XME_STATUS_OUT_OF_RESOURCES);
    {
        xme_core_exec_configStruct_t configStruct = { NULL };
        XME_CHECK(XME_STATUS_SUCCESS == xme_core_exec_init(&configStruct), XME_STATUS_OUT_OF_RESOURCES);
    }
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sharedPtr_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_tls_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_context_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_init(), XME_STATUS_OUT_OF_RESOURCES);
    {
        XME_CHECK(XME_STATUS_SUCCESS == xme_core_broker_init(NULL), XME_STATUS_OUT_OF_RESOURCES);
    }
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
cleaningGuiInit
(
	xme_core_exec_functionDescriptor_t **descriptor
)
{
    xme_status_t status;
    
    *descriptor = (xme_core_exec_functionDescriptor_t*)
    		xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
    XME_CHECK(NULL != *descriptor, XME_STATUS_OUT_OF_RESOURCES);
    xme_hal_mem_set(*descriptor, 0, sizeof(xme_core_exec_functionDescriptor_t));
    (*descriptor)->task = (xme_hal_sched_taskCallback_t)
    		(&(autopnp_adv_cleaningGui_displayImageFunctionWrapper_execute));
    (*descriptor)->taskArgs = *descriptor;
    (*descriptor)->componentId = (xme_core_component_t) 1;
    (*descriptor)->functionId = (xme_core_component_functionId_t) 1;
    (*descriptor)->init = &autopnp_adv_cleaningGui_displayImageFunction_init;
	(*descriptor)->initParam = xme_hal_mem_alloc(sizeof(xme_maxSystemValue_t));
	XME_CHECK(NULL != (*descriptor)->initParam, XME_STATUS_OUT_OF_RESOURCES);
	(*descriptor)->fini = &autopnp_adv_cleaningGui_displayImageFunction_fini;
	(*descriptor)->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(500);

	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadataElements[1];
	    metadataElements[0].key = (xme_core_attribute_key_t) 0;
	    metadataElements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadataElements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
	        XME_CORE_TOPIC(AUTOPNP_TOPIC_IMAGE),
	        sizeof(autopnp_topic_image_t),
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        &(ports[0])
	    );
	    
	    // TODO: Decide whether this should stay here for plug and player related components
	    xme_core_directory_pnpClient_announceStaticComponentPort
		(
		    XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
			XME_CORE_TOPIC(AUTOPNP_TOPIC_IMAGE),
		    sizeof(autopnp_topic_image_t),
			&(ports[0]),
			(*descriptor)
	  	);
	
	    XME_ASSERT(XME_STATUS_SUCCESS == status);
	}
	

	autopnp_adv_cleaningGui_cleaningGuiComponentWrapper_receivePort
	(
		ports[0],
		AUTOPNP_ADV_CLEANINGGUI_CLEANINGGUICOMPONENTWRAPPER_PORT_IMAGEIN
	);

    // Register with broker
    xme_core_broker_registerFunction
    (
    	(*descriptor)->componentId,
    	(*descriptor)->functionId,
    	(*descriptor)
    );
    xme_core_broker_addDataPacketToFunction
    (
    	ports[0],
    	(*descriptor)->componentId,
    	(*descriptor)->functionId,
    	(*descriptor),
    	true
    );

    return XME_STATUS_SUCCESS;
}

void
cleaningGuiFini
(
	xme_core_exec_functionDescriptor_t* descriptor
)
{
	xme_hal_mem_free(descriptor);
	xme_hal_mem_free(descriptor->initParam);
}

xme_status_t
marshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(autopnp_wp_marshaler_marshalerFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		autopnp_wp_marshaler_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
marshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
)
{
	xme_status_t status;
	
	// Create subscription port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        inputDataPort
		);
	
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	// Create publication port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        outputDataPort
		);
	
	     XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	autopnp_wp_marshaler_addConfig
	(
	    instanceId,
	    topic,
	    *inputDataPort,
	    *outputDataPort
	);
	
	// Register with broker
	xme_core_broker_registerFunction
	(
	        (*descriptor)->componentId,
	        (*descriptor)->functionId,
	        (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	xme_core_broker_addDataPacketToFunction
	(
	        *inputDataPort,
	        (*descriptor)->componentId,
	        (*descriptor)->functionId,
	        (xme_core_component_functionVariantId_t)(*instanceId),
	        true
	);
	
	return XME_STATUS_SUCCESS;
}

void
marshalerWaypointFini(void)
{
	autopnp_wp_marshaler_fini();
}

xme_status_t
demarshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(autopnp_wp_marshaler_demarshalerFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		autopnp_wp_demarshaler_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
demarshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
)
{
	xme_status_t status;
	
	// Create subscription port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        inputDataPort
		);
	
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	// Create publication port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        outputDataPort
		);
	
	     XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	autopnp_wp_demarshaler_addConfig
	(
	    instanceId,
	    topic,
	    *inputDataPort,
	    *outputDataPort
	);
	
	// Register with broker
	xme_core_broker_registerFunction
	(
        (*descriptor)->componentId,
        (*descriptor)->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	xme_core_broker_addDataPacketToFunction
	(
        *inputDataPort,
        (*descriptor)->componentId,
        (*descriptor)->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
	);
	
	return XME_STATUS_SUCCESS;
}

void
demarshalerWaypointFini(void)
{
	autopnp_wp_demarshaler_fini();
}

xme_status_t
udpSendWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(xme_wp_udp_udpSend_udpSendWayPointFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		xme_wp_udp_udpSend_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
udpSendWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer
)
{
	xme_status_t status;
	
	// Create subscription
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
	        topic,
	        sizeOfTopic,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        dataPort
	    );
	    
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	    
	    {
			uint16_t bufferSize;
			
			bufferSize = sizeOfTopic + xme_wp_udp_udpSend_getPackageOverHead();
			
			sendBuffer = xme_hal_mem_alloc(bufferSize);
			
			XME_CHECK(NULL != sendBuffer, XME_STATUS_INTERNAL_ERROR);
			
			status = xme_wp_udp_udpSend_addConfig
			(
			    instanceId,
				*dataPort,
				sizeOfTopic,
				sendBuffer,
				bufferSize,
				key,
				destIP,
				ipPort
			);
			
			XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		}
	}
	
	// Register with broker
	xme_core_broker_registerFunction
	(
	    (*descriptor)->componentId,
	    (*descriptor)->functionId,
	    (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	xme_core_broker_addDataPacketToFunction
	(
	    *dataPort,
	    (*descriptor)->componentId,
	    (*descriptor)->functionId,
	    (xme_core_component_functionVariantId_t)(*instanceId),
	    true
	);
	
	return XME_STATUS_SUCCESS;
}

void
udpSendWaypointFini(void)
{
	xme_wp_udp_udpSend_fini();
}

xme_status_t
udpReceiveWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(xme_wp_udp_udpReceive_udpReceiveWayPointFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		xme_wp_udp_udpReceive_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
udpReceiveWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
)
{
	xme_status_t status;
	
	// Create publication
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
	        topic,
	        sizeOfTopic,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        dataPort
	    );
	    
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	    
	    {
			uint16_t bufferSize;
			
			bufferSize = sizeOfTopic + xme_wp_udp_udpReceive_getPackageOverHead();
			
			recvBuffer = xme_hal_mem_alloc(bufferSize);
			
			XME_CHECK(NULL != recvBuffer, XME_STATUS_INTERNAL_ERROR);
			
			xme_wp_udp_udpReceive_addConfig
			(
			    instanceId,
			    *dataPort,
			    sizeOfTopic,
			    recvBuffer,
			    bufferSize,
			    key,
			    ipPort
			);
		}
	}
	
	// Register with broker
	xme_core_broker_registerFunction
	(
	    (*descriptor)->componentId,
	    (*descriptor)->functionId,
	    (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	return XME_STATUS_SUCCESS;
}

void
udpReceiveWaypointFini(void)
{
	xme_wp_udp_udpReceive_fini();
}


void
addDataPacketTransferEntries(void)
{
}

int
main(int argc, char* argv[])
{
	xme_status_t status;
    xme_core_exec_schedule_handle_t scheduleId;
    xme_core_exec_schedule_table_t* nodeSchedules[1];
	xme_core_exec_functionDescriptor_t* cleaningGuiComponentWrapper = NULL;

    XME_UNUSED_PARAMETER(argc);
    XME_UNUSED_PARAMETER(argv);

    status = xmeInit();
    if (XME_STATUS_SUCCESS != status)
    {
		XME_LOG
		(
			XME_LOG_FATAL,
			"Error occurred during initialization of CHROMOSOME core components. Aborting execution."
		);
    	return status;
    }
    
    cleaningGuiInit(&cleaningGuiComponentWrapper);

    addDataPacketTransferEntries();

    // Execution Manager and Scheduler

    // Configure dispatcher
    xme_core_exec_dispatcher_createFunctionExecutionUnit(cleaningGuiComponentWrapper, true);

    // Configure schedule
    xme_core_exec_scheduler_createScheduleTable
    (
    	&(nodeSchedules[0]),
    	xme_hal_time_timeIntervalFromMilliseconds(1200)
    );

	xme_core_exec_scheduler_addElementToScheduleTable
	(
		nodeSchedules[0],
		cleaningGuiComponentWrapper->componentId,
		cleaningGuiComponentWrapper->functionId,
		cleaningGuiComponentWrapper->taskArgs,
		xme_hal_time_timeIntervalFromMilliseconds(0),
		xme_hal_time_timeIntervalFromMilliseconds(500),
		true
	);

    xme_core_exec_scheduler_registerSchedule(nodeSchedules[0], &scheduleId);

    // Activate schedule
    xme_core_exec_scheduler_activateSchedule(scheduleId);

    // Run the schedule multiple times
    xme_core_exec_run(0, false);
    xme_core_exec_fini();

	// Fini waypoints
    
    // Fini components
    cleaningGuiFini(cleaningGuiComponentWrapper);

    return 0;
}
