/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id$
 */

/**
 * \file
 *         Main file of node 'masterNode'.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (XMT)
 *         (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "autopnp/adv/loginServer/include/checkLoginRequestsFunction.h"
#include "autopnp/adv/loginServer/include/checkLoginRequestsFunctionWrapper.h"
#include "autopnp/adv/loginServer/include/loginServerComponentWrapper.h"
#include "autopnp/adv/pnpManager/include/pnpManagerComponentWrapper.h"
#include "autopnp/adv/pnpManager/include/pnpManagerFunction.h"
#include "autopnp/adv/pnpManager/include/pnpManagerFunctionWrapper.h"
#include "autopnp/topic/dictionary.h"
#include "autopnp/wp/marshaler/include/demarshaler.h"
#include "autopnp/wp/marshaler/include/demarshalerFunctionWrapper.h"
#include "autopnp/wp/marshaler/include/marshaler.h"
#include "autopnp/wp/marshaler/include/marshalerFunctionWrapper.h"
#include "xme/core/broker/include/broker.h"
#include "xme/core/broker/include/brokerPnpManagerInterface.h"
#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/directory/include/dataLinkGraph.h"
#include "xme/core/directory/include/logicalRouteManager.h"
#include "xme/core/directory/include/node.h"
#include "xme/core/directory/include/plugAndPlayClient.h"
#include "xme/core/directory/include/plugAndPlayManager.h"
#include "xme/core/executionManager/include/executionManagerScheduleManagementInterface.h"
#include "xme/core/log.h"
#include "xme/core/manifestRepository/include/manifestRepository.h"
#include "xme/core/topic.h"
#include "xme/hal/include/context.h"
#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/sharedPtr.h"
#include "xme/hal/include/sync.h"
#include "xme/hal/include/time.h"
#include "xme/hal/include/tls.h"
#include "xme/wp/udp/include/udpReceive.h"
#include "xme/wp/udp/include/udpReceiveWayPointFunctionWrapper.h"
#include "xme/wp/udp/include/udpSend.h"
#include "xme/wp/udp/include/udpSendWayPointFunctionWrapper.h"

/******************************************************************************/
/***   Static variables                                                     ***/
/******************************************************************************/


/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Initialize CHROMOSOME hal and core components.
 *
 * \retval XME_STATUS_SUCCESS when initialization succeeded without problems.
 * \retval XME_STATUS_OUT_OF_RESOURCES when an error occured during initialization
 *         of one of the core components.
 */
xme_status_t 
xmeInit(void);

/**
 * \brief  Initialize data structures of pnp related components.
 *
 * \details Adds information about the initial components on this node to the
 *          logical route manager, plug and play manager and network
 *          communication manager.
 *
 * \retval XME_STATUS_SUCCESS when initialization succeeded without problems.
 * \retval XME_STATUS_OUT_OF_RESOURCES when an error occured during initialization.
 */
xme_status_t
pnpInit(void);

/**
 * \brief  Initialize component 'pnpManager'.
 *
 * \details Creates ports, populates given function descriptor and registers component
 *          functions at the broker.
 *
 * \param  descriptor Function descriptor for this component.
 *
 * \retval XME_STATUS_SUCCESS When initialization succeded without errors.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 * \retval XME_STATUS_INTERNAL_ERROR When an error occured during initialization.
 */
xme_status_t
pnpManagerInit
(
	xme_core_exec_functionDescriptor_t** descriptor
);

/**
 * \brief  Frees resources allocated by component 'pnpManager'.
 *
 * \param  descriptor Function descriptor of the component that should be finalized.
 */
void
pnpManagerFini
(
	xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Initialize component 'loginServer'.
 *
 * \details Creates ports, populates given function descriptor and registers component
 *          functions at the broker.
 *
 * \param  descriptor Function descriptor for this component.
 *
 * \retval XME_STATUS_SUCCESS When initialization succeded without errors.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 * \retval XME_STATUS_INTERNAL_ERROR When an error occured during initialization.
 */
xme_status_t
loginServerInit
(
	xme_core_exec_functionDescriptor_t** descriptor
);

/**
 * \brief  Frees resources allocated by component 'loginServer'.
 *
 * \param  descriptor Function descriptor of the component that should be finalized.
 */
void
loginServerFini
(
	xme_core_exec_functionDescriptor_t* descriptor
);


/**
 * \brief  Initialize marshaler waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
marshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the marshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the marshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  inputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
marshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
marshalerWaypointFini(void);

/**
 * \brief  Initialize demarshaler waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
demarshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the demarshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the demarshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  outputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
demarshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
demarshalerWaypointFini(void);

/**
 * \brief  Initialize udp send waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
udpSendWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp send waypoint.
 *
 * \details Creates and adds configuration structure for udp send waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpSend_addConfig.
 * \param  destIP See hostname parameter of xme_wp_udp_udpSend_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpSend_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpSend_addConfig.
 * \param  sendBuffer See buffer parameter of xme_wp_udp_udpSend_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpSendWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
udpSendWaypointFini(void);

/**
 * \brief  Initialize udp receive waypoint.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
udpReceiveWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp receive waypoint.
 *
 * \details Creates and adds configuration structure for udp receive waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  recvBuffer See buffer parameter of xme_wp_udp_udpReceive_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpReceiveWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
udpReceiveWaypointFini(void);

/**
 * \brief  Add packet transfer entries for all ports to the broker.
 */
void
addDataPacketTransferEntries(void);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xmeInit(void)
{
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sync_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sched_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_manifestRepository_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_init(18), XME_STATUS_OUT_OF_RESOURCES);
    {
        xme_core_exec_configStruct_t configStruct = { NULL };
        XME_CHECK(XME_STATUS_SUCCESS == xme_core_exec_init(&configStruct), XME_STATUS_OUT_OF_RESOURCES);
    }
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sharedPtr_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_tls_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_context_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_init(), XME_STATUS_OUT_OF_RESOURCES);
    {
        XME_CHECK(XME_STATUS_SUCCESS == xme_core_broker_init(NULL), XME_STATUS_OUT_OF_RESOURCES);
    }
    
    // FIXME: We are creating statically both sensor and monitor component type manifests. 
    //        In the future, this should be generated from the modeling tool. 
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_pnp_pnpManager_createSensorComponentTypeManifest(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_pnp_pnpManager_createMonitorComponentTypeManifest(), XME_STATUS_OUT_OF_RESOURCES);
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
pnpInit(void)
{
	xme_status_t status;
	
	// Announce component ports to logicalRouteManager
	
	
	// Announce already established routes to logical route manager
	{
		xme_hal_graph_graph_t routes;
		xme_hal_graph_edgeId_t currentEdge;
		xme_core_directory_dataLinkGraph_edgeData_t* ed;
		
		status = xme_core_directory_logicalRouteManager_getLogicalRoutes(&routes, XME_CORE_INVALID_TRANSACTION_ID);
		XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		
	    status = xme_hal_graph_setEdgeCompareCallback
	    (
	    	&routes, 
	    	&xme_core_directory_dataLinkGraph_edgeCompareFilterLogicalRoutes
	    );
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		
		currentEdge = XME_HAL_GRAPH_INVALID_EDGE_ID;
		for (;;)
		{
		    currentEdge = xme_hal_graph_getNextEdgeWithDataComparison(&routes, NULL, currentEdge);
		    if (XME_HAL_GRAPH_INVALID_EDGE_ID == currentEdge)
		    {
		        break;
		    }
		
		    status = xme_hal_graph_getEdgeData(&routes, currentEdge, (void**) &ed);
		    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		    status = xme_core_directory_logicalRouteManager_setLogicalRoute(ed->edgeId, ed->edgeData.logicalRouteEdge.channelId, XME_CORE_INVALID_TRANSACTION_ID);
		    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		}
	}
	
	// Register all nodes and their interfaces
	
	// Register node 'masterNode'
	{
		status = xme_core_directory_node_registerNode((xme_core_node_nodeId_t)1, "masterNode");
		XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		
		{
			xme_core_directory_node_nodeInterface_t nodeInterface;
		
			nodeInterface.interfaceType = XME_CORE_DIRECTORY_NCC_INTERFACETYPE_ETHERNET_INTERFACE;
			nodeInterface.interfaceAddress.ipAddress.ip = "127.0.0.1";
			nodeInterface.interfaceAddress.ipAddress.port = 32221;
		
			status = xme_core_directory_node_addInterface((xme_core_node_nodeId_t)1, nodeInterface);
			XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		}
	}
	
	// Register node 'cleaningGuiNode'
	{
		status = xme_core_directory_node_registerNode((xme_core_node_nodeId_t)2, "cleaningGuiNode");
		XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		
		{
			xme_core_directory_node_nodeInterface_t nodeInterface;
		
			nodeInterface.interfaceType = XME_CORE_DIRECTORY_NCC_INTERFACETYPE_ETHERNET_INTERFACE;
			nodeInterface.interfaceAddress.ipAddress.ip = "127.0.0.1";
			nodeInterface.interfaceAddress.ipAddress.port = 32221;
		
			status = xme_core_directory_node_addInterface((xme_core_node_nodeId_t)2, nodeInterface);
			XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		}
	}
	
	// Add component instances to pnpManager
	
	// Component 'pnpManager'
	{
		xme_core_pnp_pnpManager_instanceId_t instanceId;
		
		instanceId = xme_core_pnp_pnpManager_createInstance((xme_core_node_nodeId_t) 1, (xme_core_component_t) 1);
		XME_CHECK(XME_CORE_PNP_PNPMANAGER_INSTANCEID_INVALID != instanceId, XME_STATUS_INTERNAL_ERROR);
		
		status = xme_core_pnp_pnpManager_updateInstance(instanceId, XME_CORE_PNP_PNPMANAGER_INSTANCE_RUNNING);
		XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);					
	}
	
	// Component 'loginServer'
	{
		xme_core_pnp_pnpManager_instanceId_t instanceId;
		
		instanceId = xme_core_pnp_pnpManager_createInstance((xme_core_node_nodeId_t) 1, (xme_core_component_t) 2);
		XME_CHECK(XME_CORE_PNP_PNPMANAGER_INSTANCEID_INVALID != instanceId, XME_STATUS_INTERNAL_ERROR);
		
		status = xme_core_pnp_pnpManager_updateInstance(instanceId, XME_CORE_PNP_PNPMANAGER_INSTANCE_RUNNING);
		XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);					
	}
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
pnpManagerInit
(
	xme_core_exec_functionDescriptor_t **descriptor
)
{
    *descriptor = (xme_core_exec_functionDescriptor_t*)
    		xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
    XME_CHECK(NULL != *descriptor, XME_STATUS_OUT_OF_RESOURCES);
    xme_hal_mem_set(*descriptor, 0, sizeof(xme_core_exec_functionDescriptor_t));
    (*descriptor)->task = (xme_hal_sched_taskCallback_t)
    		(&(autopnp_adv_pnpManager_pnpManagerFunctionWrapper_execute));
    (*descriptor)->taskArgs = *descriptor;
    (*descriptor)->componentId = (xme_core_component_t) 1;
    (*descriptor)->functionId = (xme_core_component_functionId_t) 1;
    (*descriptor)->init = &autopnp_adv_pnpManager_pnpManagerFunction_init;
	(*descriptor)->initParam = xme_hal_mem_alloc(sizeof(xme_maxSystemValue_t));
	XME_CHECK(NULL != (*descriptor)->initParam, XME_STATUS_OUT_OF_RESOURCES);
	(*descriptor)->fini = &autopnp_adv_pnpManager_pnpManagerFunction_fini;
	(*descriptor)->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(200);



    // Register with broker
    xme_core_broker_registerFunction
    (
    	(*descriptor)->componentId,
    	(*descriptor)->functionId,
    	(*descriptor)
    );

    return XME_STATUS_SUCCESS;
}

void
pnpManagerFini
(
	xme_core_exec_functionDescriptor_t* descriptor
)
{
	xme_hal_mem_free(descriptor);
	xme_hal_mem_free(descriptor->initParam);
}

xme_status_t
loginServerInit
(
	xme_core_exec_functionDescriptor_t **descriptor
)
{
    *descriptor = (xme_core_exec_functionDescriptor_t*)
    		xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
    XME_CHECK(NULL != *descriptor, XME_STATUS_OUT_OF_RESOURCES);
    xme_hal_mem_set(*descriptor, 0, sizeof(xme_core_exec_functionDescriptor_t));
    (*descriptor)->task = (xme_hal_sched_taskCallback_t)
    		(&(autopnp_adv_loginServer_checkLoginRequestsFunctionWrapper_execute));
    (*descriptor)->taskArgs = *descriptor;
    (*descriptor)->componentId = (xme_core_component_t) 2;
    (*descriptor)->functionId = (xme_core_component_functionId_t) 1;
    (*descriptor)->init = &autopnp_adv_loginServer_checkLoginRequestsFunction_init;
	(*descriptor)->initParam = xme_hal_mem_alloc(sizeof(xme_maxSystemValue_t));
	XME_CHECK(NULL != (*descriptor)->initParam, XME_STATUS_OUT_OF_RESOURCES);
	(*descriptor)->fini = &autopnp_adv_loginServer_checkLoginRequestsFunction_fini;
	(*descriptor)->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(500);



    // Register with broker
    xme_core_broker_registerFunction
    (
    	(*descriptor)->componentId,
    	(*descriptor)->functionId,
    	(*descriptor)
    );

    return XME_STATUS_SUCCESS;
}

void
loginServerFini
(
	xme_core_exec_functionDescriptor_t* descriptor
)
{
	xme_hal_mem_free(descriptor);
	xme_hal_mem_free(descriptor->initParam);
}

xme_status_t
marshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(autopnp_wp_marshaler_marshalerFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		autopnp_wp_marshaler_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
marshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
)
{
	xme_status_t status;
	
	// Create subscription port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        inputDataPort
		);
	
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	// Create publication port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        outputDataPort
		);
	
	     XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	autopnp_wp_marshaler_addConfig
	(
	    instanceId,
	    topic,
	    *inputDataPort,
	    *outputDataPort
	);
	
	// Register with broker
	xme_core_broker_registerFunction
	(
	        (*descriptor)->componentId,
	        (*descriptor)->functionId,
	        (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	xme_core_broker_addDataPacketToFunction
	(
	        *inputDataPort,
	        (*descriptor)->componentId,
	        (*descriptor)->functionId,
	        (xme_core_component_functionVariantId_t)(*instanceId),
	        true
	);
	
	return XME_STATUS_SUCCESS;
}

void
marshalerWaypointFini(void)
{
	autopnp_wp_marshaler_fini();
}

xme_status_t
demarshalerWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(autopnp_wp_marshaler_demarshalerFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		autopnp_wp_demarshaler_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
demarshalerWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
	xme_core_topic_t topic,
	uint16_t topicSize
)
{
	xme_status_t status;
	
	// Create subscription port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        inputDataPort
		);
	
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	// Create publication port
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
	        topic,
	        topicSize,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        outputDataPort
		);
	
	     XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	}
	
	autopnp_wp_demarshaler_addConfig
	(
	    instanceId,
	    topic,
	    *inputDataPort,
	    *outputDataPort
	);
	
	// Register with broker
	xme_core_broker_registerFunction
	(
        (*descriptor)->componentId,
        (*descriptor)->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	xme_core_broker_addDataPacketToFunction
	(
        *inputDataPort,
        (*descriptor)->componentId,
        (*descriptor)->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
	);
	
	return XME_STATUS_SUCCESS;
}

void
demarshalerWaypointFini(void)
{
	autopnp_wp_demarshaler_fini();
}

xme_status_t
udpSendWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(xme_wp_udp_udpSend_udpSendWayPointFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		xme_wp_udp_udpSend_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
udpSendWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer
)
{
	xme_status_t status;
	
	// Create subscription
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
	        topic,
	        sizeOfTopic,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        dataPort
	    );
	    
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	    
	    {
			uint16_t bufferSize;
			
			bufferSize = sizeOfTopic + xme_wp_udp_udpSend_getPackageOverHead();
			
			sendBuffer = xme_hal_mem_alloc(bufferSize);
			
			XME_CHECK(NULL != sendBuffer, XME_STATUS_INTERNAL_ERROR);
			
			status = xme_wp_udp_udpSend_addConfig
			(
			    instanceId,
				*dataPort,
				sizeOfTopic,
				sendBuffer,
				bufferSize,
				key,
				destIP,
				ipPort
			);
			
			XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
		}
	}
	
	// Register with broker
	xme_core_broker_registerFunction
	(
	    (*descriptor)->componentId,
	    (*descriptor)->functionId,
	    (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	xme_core_broker_addDataPacketToFunction
	(
	    *dataPort,
	    (*descriptor)->componentId,
	    (*descriptor)->functionId,
	    (xme_core_component_functionVariantId_t)(*instanceId),
	    true
	);
	
	return XME_STATUS_SUCCESS;
}

void
udpSendWaypointFini(void)
{
	xme_wp_udp_udpSend_fini();
}

xme_status_t
udpReceiveWaypointInit
(
	xme_core_exec_functionDescriptor_t** descriptor,
	xme_core_component_t componentId
)
{
	static xme_core_exec_functionDescriptor_t* desc = NULL;

	if (NULL == desc)
	{
		desc = (xme_core_exec_functionDescriptor_t*)
				xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
		XME_CHECK(NULL != desc, XME_STATUS_OUT_OF_RESOURCES);
		xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
		desc->task = (xme_hal_sched_taskCallback_t)
				&(xme_wp_udp_udpReceive_udpReceiveWayPointFunctionWrapper_execute);
		desc->taskArgs = desc;
		desc->componentId = componentId;
		desc->functionId = (xme_core_component_functionId_t) 1;
		desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
		
		xme_wp_udp_udpReceive_init();
		
		xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
	}
	
	*descriptor = desc;
	
	return XME_STATUS_SUCCESS;
}

xme_status_t
udpReceiveWaypointAddConfig
(
	xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
)
{
	xme_status_t status;
	
	// Create publication
	{
	    xme_core_attribute_descriptor_list_t metadata;
	    xme_core_attribute_descriptor_t metadata_elements[1];
	    metadata_elements[0].key = (xme_core_attribute_key_t) 0;
	    metadata_elements[0].size = (size_t) 0;
	    metadata.length = 1;
	    metadata.element = metadata_elements;
	
	    status = xme_core_dataHandler_createPort
	    (
	        (*descriptor)->componentId,
	        XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
	        topic,
	        sizeOfTopic,
	        metadata,
	        1,
	        false,
	        false,
	        0,
	        dataPort
	    );
	    
	    XME_CHECK(XME_STATUS_SUCCESS == status, XME_STATUS_INTERNAL_ERROR);
	    
	    {
			uint16_t bufferSize;
			
			bufferSize = sizeOfTopic + xme_wp_udp_udpReceive_getPackageOverHead();
			
			recvBuffer = xme_hal_mem_alloc(bufferSize);
			
			XME_CHECK(NULL != recvBuffer, XME_STATUS_INTERNAL_ERROR);
			
			xme_wp_udp_udpReceive_addConfig
			(
			    instanceId,
			    *dataPort,
			    sizeOfTopic,
			    recvBuffer,
			    bufferSize,
			    key,
			    ipPort
			);
		}
	}
	
	// Register with broker
	xme_core_broker_registerFunction
	(
	    (*descriptor)->componentId,
	    (*descriptor)->functionId,
	    (xme_core_component_functionVariantId_t)(*instanceId)
	);
	
	return XME_STATUS_SUCCESS;
}

void
udpReceiveWaypointFini(void)
{
	xme_wp_udp_udpReceive_fini();
}


void
addDataPacketTransferEntries(void)
{
}

int
main(int argc, char* argv[])
{
	xme_status_t status;
    xme_core_exec_schedule_handle_t scheduleId;
    xme_core_exec_schedule_table_t* nodeSchedules[1];
	xme_core_exec_functionDescriptor_t* pnpManagerComponentWrapper = NULL;
	xme_core_exec_functionDescriptor_t* loginServerComponentWrapper = NULL;

    XME_UNUSED_PARAMETER(argc);
    XME_UNUSED_PARAMETER(argv);

    status = xmeInit();
    if (XME_STATUS_SUCCESS != status)
    {
		XME_LOG
		(
			XME_LOG_FATAL,
			"Error occurred during initialization of CHROMOSOME core components. Aborting execution."
		);
    	return status;
    }
    
    status = pnpInit();
    if (XME_STATUS_SUCCESS != status)
    {
    	XME_LOG
    	(
    		XME_LOG_FATAL,
    		"Error occurred during initialization of CHROMOSOME pnp components. Aborting execution."
    	);
    	return status;
    }
    pnpManagerInit(&pnpManagerComponentWrapper);
    loginServerInit(&loginServerComponentWrapper);

    addDataPacketTransferEntries();

    // Execution Manager and Scheduler

    // Configure dispatcher
    xme_core_exec_dispatcher_createFunctionExecutionUnit(pnpManagerComponentWrapper, true);
    xme_core_exec_dispatcher_createFunctionExecutionUnit(loginServerComponentWrapper, true);

    // Configure schedule
    xme_core_exec_scheduler_createScheduleTable
    (
    	&(nodeSchedules[0]),
    	xme_hal_time_timeIntervalFromMilliseconds(1200)
    );

	xme_core_exec_scheduler_addElementToScheduleTable
	(
		nodeSchedules[0],
		pnpManagerComponentWrapper->componentId,
		pnpManagerComponentWrapper->functionId,
		pnpManagerComponentWrapper->taskArgs,
		xme_hal_time_timeIntervalFromMilliseconds(0),
		xme_hal_time_timeIntervalFromMilliseconds(200),
		true
	);
	xme_core_exec_scheduler_addElementToScheduleTable
	(
		nodeSchedules[0],
		loginServerComponentWrapper->componentId,
		loginServerComponentWrapper->functionId,
		loginServerComponentWrapper->taskArgs,
		xme_hal_time_timeIntervalFromMilliseconds(200),
		xme_hal_time_timeIntervalFromMilliseconds(500),
		true
	);

    xme_core_exec_scheduler_registerSchedule(nodeSchedules[0], &scheduleId);

    // Activate schedule
    xme_core_exec_scheduler_activateSchedule(scheduleId);

    // Run the schedule multiple times
    xme_core_exec_run(0, false);
    xme_core_exec_fini();

	// Fini waypoints
    
    // Fini components
    pnpManagerFini(pnpManagerComponentWrapper);
    loginServerFini(loginServerComponentWrapper);

    return 0;
}
